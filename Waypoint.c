#pragma config(Motor,  motorA,          InMotor,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "map_geometry.c"

#define SOUND_ON 0
#define CHOOSE_K 0

#define R 2.76
#define L 12.7
#define F 7.3

#define K 7.0

#define PI 3.1415926536
#define numPoints 73

//Global variables - you will need to change some of these
float robot_TH = 0.0;
point robot_c, marker_c, marker_d;
float marker_vd, marker_wd;
int oldL = 0, oldR = 0, oldT = 0;
int velocityUpdateInterval = 20;
int PIDUpdateInterval = 2;

float kp;
float l;

rect rectObstacles[3];
circle circleObstacles[3];

float max(float a, float b){
	if(a > b)
		return a;
	return b;
}

/*****************************************
 * Initiate obstacles
 *****************************************/

void initObstacles() {
	// Circles
	point center;
	center.x = 30; center.y = 30;
	new_circle(&circleObstacles[0], center, 3);

	center.x = 60; center.y = 12;
	new_circle(&circleObstacles[1], center, 3);

	center.x = 66; center.y = 39;
	new_circle(&circleObstacles[2], center, 3);

	// Rectangles
	point corners[4];
	corners[0].x = 0; corners[0].y = 24;
	corners[1].x = 22; corners[1].y = 14;
	corners[2].x = 24; corners[2].y = 20;
	corners[3].x = 2; corners[3].y = 30;
	new_rect(&rectObstacles[0], corners);

	corners[0].x = 33; corners[0].y = 18;
	corners[1].x = 37; corners[1].y = 13;
	corners[2].x = 55; corners[2].y = 28;
	corners[3].x = 52; corners[3].y = 33;
	new_rect(&rectObstacles[1], corners);

	corners[0].x = 78; corners[0].y = 24;
	corners[1].x = 72; corners[1].y = 27;
	corners[2].x = 84; corners[2].y = 48;
	corners[3].x = 90; corners[3].y = 46;
	new_rect(&rectObstacles[2], corners);
}

/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/
task trajectory_task()
{
	float t = 0.0;
	oldL = nMotorEncoder[LeftMotor];
	oldR = nMotorEncoder[RightMotor];
	oldT = nPgmTime;
	int loops = 0;
	while(1)
	{
		int curTime = nPgmTime;
		int leftEnc = nMotorEncoder[LeftMotor];
		int rightEnc = nMotorEncoder[RightMotor];
		float dt = (curTime - oldT) / 1000.0;
		t += dt;
		if(dt == 0.0){
			continue;
		}
		loops++;
		float vl = (leftEnc - oldL) / dt * PI / 180.0 * R;
		float vr = (rightEnc - oldR) / dt * PI / 180.0 * R;

		float vmax = max(abs(vr), abs(vl));
		float v = (vr + vl) / 2.0;

		float w = (vr - vl) / l;

		float k00 = v*cos(robot_TH);
		float k01 = v*sin(robot_TH);
		float k02 = w;
		float k10 = v*cos(robot_TH + k02*.5*dt);
		float k11 = v*sin(robot_TH + k02*.5*dt);
		float k12 = w;
		float k20 = v*cos(robot_TH + k12*.5*dt);
		float k21 = v*sin(robot_TH + k12*.5*dt);
		float k22 = w;
		float k30 = v*cos(robot_TH + k22*dt);
		float k31 = v*sin(robot_TH + k22*dt);
		float k32 = w;

		robot_c.x += dt/6.0 * (k00 + 2*(k10 + k20) + k30);
		robot_c.y += dt/6.0 * (k01 + 2*(k11 + k21) + k31);
		robot_TH += dt/6.0 * (k02 + 2*(k12 + k22) + k32);

		marker_c.x = robot_c.x + F * cos(robot_TH);
		marker_c.y = robot_c.y + F * sin(robot_TH);

		float xErr = marker_d.x - marker_c.x;
		float yErr = marker_d.y - marker_c.y;

		marker_vd = kp*(xErr*cos(robot_TH) + yErr*sin(robot_TH));
		marker_wd = kp*(xErr * -sin(robot_TH)/F + yErr * cos(robot_TH)/F);

		float vld = 90.0 / PI * (2.0*marker_vd - L*marker_wd) / R;
		float vrd = 90.0 / PI * (2.0*marker_vd + L*marker_wd) / R;

		motor[motorB] = 0.1 * vld;
		motor[motorC] = 0.1 * vrd;

		//Code that plots the robot's current position and also prints it out as text
		setPixel(50 + (int)(100.0 * marker_c.x), 32 + (int)(100.0 * marker_c.y));
		displayTextLine(0, "X: %f", marker_c.x);
		displayTextLine(1, "Y: %f", marker_c.y);
		displayTextLine(2, "xd: %f", marker_d.x);
		displayTextLine(3, "yd: %f", marker_d.y);
		displayTextLine(4, "t: %f", robot_TH * 180.0 / PI);
		displayTextLine(5, "x: %f", xErr);
		displayTextLine(6, "y: %f", yErr);

		wait1Msec(velocityUpdateInterval);
		oldL = leftEnc;
		oldR = rightEnc;
		oldT = curTime;
	}
}

/*****************************************
 * Trajectories - these functions define
 * the sample trajectories
 *****************************************/

float clamp (float x, float minimum, float maximum)
{
	if (x < minimum)
		return minimum;
	else if (x > maximum)
		return maximum;
	else
		return x;
}


task speedSounds(){
	while(1){
		float power = (abs(motor[motorB]) + abs(motor[motorC])) / 2.0;
		displayTextLine(7, "motor: %f", motor[motorB]);
		float freq = power/100.0 * (800 - 400);
		freq += 400;
		playTone((int)freq,5);
		sleep(3);
	}
}


/*****************************************
 * Main function - it is not necessary to
 * modify this
 *****************************************/
task main()
{
  /* Reset encoders and turn on PID control */
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

  motor[motorB] = 0;
	motor[motorC] = 0;

	initObstacles();

	for (int i = 0; i < 3; i++) {
		draw_circle(circleObstacles[i]);
	}

	nxtDisplayTextLine(0,"(%.1f, %.1f)", rectObstacles[0].corners[0].x, rectObstacles[0].corners[0].y);
	nxtDisplayTextLine(1,"(%.1f, %.1f)", rectObstacles[0].corners[1].x, rectObstacles[0].corners[1].y);
	nxtDisplayTextLine(2,"(%.1f, %.1f)", rectObstacles[0].corners[2].x, rectObstacles[0].corners[2].y);
	nxtDisplayTextLine(3,"(%.1f, %.1f)", rectObstacles[0].corners[3].x, rectObstacles[0].corners[3].y);
	while(1){}
}
