#pragma config(Motor,  motorA,          InMotor,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SOUND_ON 0
#define CHOOSE_K 0

#define ROBOTR 3
#define R 2.76
#define PETAL_L 13.05
#define L 12.7
#define F 7.3

#define K 7.0

#define PI 3.1415926536
#define numPoints 73

typedef struct coord {
	float x;
	float y;
} point;

#define MAPWIDTH 96
#define MAPHEIGHT 48

ubyte map[MAPHEIGHT][MAPWIDTH];

//Global variables - you will need to change some of these
float robot_TH = 0.0;
point robot_c, marker_c, marker_d;
float marker_vd, marker_wd;
int oldL = 0, oldR = 0, oldT = 0;
int velocityUpdateInterval = 20;
int PIDUpdateInterval = 2;

float kp;
float l;

float max(float a, float b){
	if(a > b)
		return a;
	return b;
}

/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/
task trajectory_task()
{
	float t = 0.0;
	oldL = nMotorEncoder[LeftMotor];
	oldR = nMotorEncoder[RightMotor];
	oldT = nPgmTime;
	int loops = 0;
	while(1)
	{
		int curTime = nPgmTime;
		int leftEnc = nMotorEncoder[LeftMotor];
		int rightEnc = nMotorEncoder[RightMotor];
		float dt = (curTime - oldT) / 1000.0;
		t += dt;
		if(dt == 0.0){
			continue;
		}
		loops++;
		float vl = (leftEnc - oldL) / dt * PI / 180.0 * R;
		float vr = (rightEnc - oldR) / dt * PI / 180.0 * R;

		float vmax = max(abs(vr), abs(vl));
		float v = (vr + vl) / 2.0;

		float w = (vr - vl) / l;

		float k00 = v*cos(robot_TH);
		float k01 = v*sin(robot_TH);
		float k02 = w;
		float k10 = v*cos(robot_TH + k02*.5*dt);
		float k11 = v*sin(robot_TH + k02*.5*dt);
		float k12 = w;
		float k20 = v*cos(robot_TH + k12*.5*dt);
		float k21 = v*sin(robot_TH + k12*.5*dt);
		float k22 = w;
		float k30 = v*cos(robot_TH + k22*dt);
		float k31 = v*sin(robot_TH + k22*dt);
		float k32 = w;

		robot_c.x += dt/6.0 * (k00 + 2*(k10 + k20) + k30);
		robot_c.y += dt/6.0 * (k01 + 2*(k11 + k21) + k31);
		robot_TH += dt/6.0 * (k02 + 2*(k12 + k22) + k32);

		marker_c.x = robot_c.x + F * cos(robot_TH);
		marker_c.y = robot_c.y + F * sin(robot_TH);

		// trajectory(tn, t, marker_d);

		float xErr = marker_d.x - marker_c.x;
		float yErr = marker_d.y - marker_c.y;

		marker_vd = kp*(xErr*cos(robot_TH) + yErr*sin(robot_TH));
		marker_wd = kp*(xErr * -sin(robot_TH)/F + yErr * cos(robot_TH)/F);

		float vld = 90.0 / PI * (2.0*marker_vd - L*marker_wd) / R;
		float vrd = 90.0 / PI * (2.0*marker_vd + L*marker_wd) / R;

		motor[motorB] = 0.1 * vld;
		motor[motorC] = 0.1 * vrd;

		//Code that plots the robot's current position and also prints it out as text
		setPixel(50 + (int)(100.0 * marker_c.x), 32 + (int)(100.0 * marker_c.y));
		displayTextLine(0, "X: %f", marker_c.x);
		displayTextLine(1, "Y: %f", marker_c.y);
		displayTextLine(2, "xd: %f", marker_d.x);
		displayTextLine(3, "yd: %f", marker_d.y);
		displayTextLine(4, "t: %f", robot_TH * 180.0 / PI);
		displayTextLine(5, "x: %f", xErr);
		displayTextLine(6, "y: %f", yErr);

		wait1Msec(velocityUpdateInterval);
		oldL = leftEnc;
		oldR = rightEnc;
		oldT = curTime;
	}
}

/****************************************
 * Initializing map
 * place obstacles and determine config. space
 ****************************************/

void placeCircle(int x, int y, int radius) {
	int points = 360;
	int x2, y2;
	if (0 <= x && x < MAPWIDTH &&
			0 <= y && y < MAPHEIGHT)
		map[y][x] = 1;
	//for (int r = 1; r <= radius + ROBOTR; r++) {
	int r = radius + ROBOTR;
		for (int i = 0; i < points; i+=2) {
			x2 = x + r * cosDegrees(i);
			y2 = y + r * sinDegrees(i);
			if (0 <= x2 && x2 < MAPWIDTH &&
					0 <= y2 && y2 < MAPHEIGHT)
				map[y2][x2] = 1;
		}
	//}
}

void placeRect(point p1, point p2, point p3, point p4) {
	const int res1 = 3;
	const int res2 = 16;
	int x, y;
	for (int i = 0; i < res1; i++) {
		x = (p2.x - p1.x) * i / res1 + p1.x;
		y = (p2.y - p1.y) * i / res1 + p1.y;
		placeCircle(x, y, 0);
		x = (p4.x - p3.x) * i / res1 + p3.x;
		y = (p4.y - p3.y) * i / res1 + p3.y;
		placeCircle(x, y, 0);
	}
	for (int i = 0; i < res2; i++) {
		x = (p3.x - p2.x) * i / res2 + p2.x;
		y = (p3.y - p2.y) * i / res2 + p2.y;
		placeCircle(x, y, 0);
		x = (p1.x - p4.x) * i / res2 + p4.x;
		y = (p1.y - p4.y) * i / res2 + p4.y;
		placeCircle(x, y, 0);
	}
}

void initMap() {
	// zero-initialize map
	int i, j;
	for (i = 0; i < MAPHEIGHT; i++)
		for (j = 0; j < MAPWIDTH; j++)
			map[i][j] = 0;
	// place obstacles
	int r = 3;
	placeCircle(30, 30, r);
	placeCircle(60, 12, r);
	placeCircle(66, 39, r);

	point p1, p2, p3, p4;
	p1.x = 0; p1.y = 24;
	p2.x = 2; p2.y = 30;
	p3.x = 24; p3.y = 20;
	p4.x = 22; p4.y = 14;
	placeRect(p1, p2, p3, p4);
	p1.x = 33; p1.y = 18;
	p2.x = 37; p2.y = 13;
	p3.x = 55; p3.y = 28;
	p4.x = 52; p4.y = 33;
	placeRect(p1, p2, p3, p4);
	p1.x = 78; p1.y = 24;
	p2.x = 72; p2.y = 27;
	p3.x = 84; p3.y = 48;
	p4.x = 90; p4.y = 46;
	placeRect(p1, p2, p3, p4);
}

void drawMap() {
	int i, j;
	for (i = 0; i < MAPHEIGHT; i++) {
		for (j = 0; j < MAPWIDTH; j++) {
			if (map[i][j] == 1) {
				setPixel(j, i);
			}
		}
	}
}

/*******
 * lol
 *******/

task speedSounds(){
	while(1){
		float power = (abs(motor[motorB]) + abs(motor[motorC])) / 2.0;
		displayTextLine(7, "motor: %f", motor[motorB]);
		float freq = power/100.0 * (800 - 400);
		freq += 400;
		playTone((int)freq,5);
		sleep(3);
	}
}


/*****************************************
 * Main function - it is not necessary to
 * modify this
 *****************************************/
task main()
{
  /* Reset encoders and turn on PID control */
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

  motor[motorB] = 0;
	motor[motorC] = 0;
	nNxtButtonTask  = 0;

	if (CHOOSE_K)
		kp = get_kp();
	else
		kp = K;

	initMap();
	drawMap();

	if(SOUND_ON){
		startTask(speedSounds);
	}

	while(nNxtButtonPressed != kExitButton) {}
}
